{"version":3,"file":"nft.js","sources":["../node_modules/near-sdk-js/lib/near-bindgen.js","../node_modules/near-sdk-js/lib/api.js","../node_modules/near-sdk-js/lib/near-contract.js","../node_modules/near-sdk-js/lib/collections/lookup-map.js","../node_modules/near-sdk-js/lib/utils.js","../node_modules/near-sdk-js/lib/collections/vector.js","../node_modules/near-sdk-js/lib/collections/unordered-map.js","../node_modules/near-sdk-js/lib/collections/unordered-set.js","../src/nft-contract/metadata.ts","../src/nft-contract/index.ts"],"sourcesContent":["export function call(target, key, descriptor) {\n}\nexport function view(target, key, descriptor) {\n}\nexport function NearBindgen(target) {\n    return class extends target {\n        static _init() {\n            // @ts-ignore\n            let args = target.deserializeArgs();\n            let ret = new target(args);\n            // @ts-ignore\n            ret.init();\n            // @ts-ignore\n            ret.serialize();\n            return ret;\n        }\n        static _get() {\n            let ret = Object.create(target.prototype);\n            return ret;\n        }\n    };\n}\n","const U64_MAX = 2n ** 64n - 1n;\nconst EVICTED_REGISTER = U64_MAX - 1n;\nexport function log(...params) {\n    env.log(`${params\n        .map(x => x === undefined ? 'undefined' : x) // Stringify undefined\n        .map(x => typeof (x) === 'object' ? JSON.stringify(x) : x) // Convert Objects to strings\n        .join(' ')}` // Convert to string\n    );\n}\nexport function signerAccountId() {\n    env.signer_account_id(0);\n    return env.read_register(0);\n}\nexport function signerAccountPk() {\n    env.signer_account_pk(0);\n    return env.read_register(0);\n}\nexport function predecessorAccountId() {\n    env.predecessor_account_id(0);\n    return env.read_register(0);\n}\nexport function blockIndex() {\n    return env.block_index();\n}\nexport function blockHeight() {\n    return blockIndex();\n}\nexport function blockTimestamp() {\n    return env.block_timestamp();\n}\nexport function epochHeight() {\n    return env.epoch_height();\n}\nexport function attachedDeposit() {\n    return env.attached_deposit();\n}\nexport function prepaidGas() {\n    return env.prepaid_gas();\n}\nexport function usedGas() {\n    return env.used_gas();\n}\nexport function randomSeed() {\n    env.random_seed(0);\n    return env.read_register(0);\n}\nexport function sha256(value) {\n    env.sha256(value, 0);\n    return env.read_register(0);\n}\nexport function keccak256(value) {\n    env.keccak256(value, 0);\n    return env.read_register(0);\n}\nexport function keccak512(value) {\n    env.keccak512(value, 0);\n    return env.read_register(0);\n}\nexport function ripemd160(value) {\n    env.ripemd160(value, 0);\n    return env.read_register(0);\n}\nexport function ecrecover(hash, sig, v, malleabilityFlag) {\n    let ret = env.ecrecover(hash, sig, v, malleabilityFlag, 0);\n    if (ret === 0n) {\n        return null;\n    }\n    return env.read_register(0);\n}\nexport function panic(msg) {\n    if (msg !== undefined) {\n        env.panic(msg);\n    }\n    else {\n        env.panic();\n    }\n}\nexport function panicUtf8(msg) {\n    env.panic_utf8(msg);\n}\nexport function logUtf8(msg) {\n    env.log_utf8(msg);\n}\nexport function logUtf16(msg) {\n    env.log_utf16(msg);\n}\nexport function storageRead(key) {\n    let ret = env.storage_read(key, 0);\n    if (ret === 1n) {\n        return env.read_register(0);\n    }\n    else {\n        return null;\n    }\n}\nexport function storageHasKey(key) {\n    let ret = env.storage_has_key(key);\n    if (ret === 1n) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function validatorStake(accountId) {\n    return env.validator_stake(accountId);\n}\nexport function validatorTotalStake() {\n    return env.validator_total_stake();\n}\nexport function altBn128G1Multiexp(value) {\n    env.alt_bn128_g1_multiexp(value, 0);\n    return env.read_register(0);\n}\nexport function altBn128G1Sum(value) {\n    env.alt_bn128_g1_sum(value, 0);\n    return env.read_register(0);\n}\nexport function altBn128PairingCheck(value) {\n    let ret = env.alt_bn128_pairing_check(value);\n    if (ret === 1n) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function jsvmAccountId() {\n    env.jsvm_account_id(0);\n    return env.read_register(0);\n}\nexport function jsvmJsContractName() {\n    env.jsvm_js_contract_name(0);\n    return env.read_register(0);\n}\nexport function jsvmMethodName() {\n    env.jsvm_method_name(0);\n    return env.read_register(0);\n}\nexport function jsvmArgs() {\n    env.jsvm_args(0);\n    return env.read_register(0);\n}\nexport function jsvmStorageWrite(key, value) {\n    let exist = env.jsvm_storage_write(key, value, EVICTED_REGISTER);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function jsvmStorageRead(key) {\n    let exist = env.jsvm_storage_read(key, 0);\n    if (exist === 1n) {\n        return env.read_register(0);\n    }\n    return null;\n}\nexport function jsvmStorageRemove(key) {\n    let exist = env.jsvm_storage_remove(key, EVICTED_REGISTER);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function jsvmStorageHasKey(key) {\n    let exist = env.jsvm_storage_has_key(key);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function jsvmCallRaw(contractName, method, args) {\n    env.jsvm_call(contractName, method, JSON.stringify(args), 0);\n    return env.read_register(0);\n}\nexport function jsvmCall(contractName, method, args) {\n    let ret = jsvmCallRaw(contractName, method, args);\n    if (ret === null) {\n        return ret;\n    }\n    return JSON.parse(ret);\n}\nexport function storageGetEvicted() {\n    return env.read_register(EVICTED_REGISTER);\n}\nexport function jsvmValueReturn(value) {\n    env.jsvm_value_return(value);\n}\n// Standalone only APIs\nexport function currentAccountId() {\n    env.current_account_id(0);\n    return env.read_register(0);\n}\nexport function input() {\n    env.input(0);\n    return env.read_register(0);\n}\nexport function storageUsage() {\n    return env.storage_usage();\n}\nexport function accountBalance() {\n    return env.account_balance();\n}\nexport function accountLockedBalance() {\n    return env.account_locked_balance();\n}\nexport function valueReturn(value) {\n    env.value_return(value);\n}\nexport function promiseCreate(accountId, methodName, args, amount, gas) {\n    return env.promise_create(accountId, methodName, args, amount, gas);\n}\nexport function promiseThen(promiseIndex, accountId, methodName, args, amount, gas) {\n    return env.promise_then(promiseIndex, accountId, methodName, args, amount, gas);\n}\nexport function promiseAnd(...promiseIndex) {\n    return env.promise_and(...promiseIndex);\n}\nexport function promiseBatchCreate(accountId) {\n    return env.promise_batch_create(accountId);\n}\nexport function promiseBatchThen(promiseIndex, accountId) {\n    return env.promise_batch_then(promiseIndex, accountId);\n}\nexport function promiseBatchActionCreateAccount(promiseIndex) {\n    env.promise_batch_action_create_account(promiseIndex);\n}\nexport function promiseBatchActionDeployContract(promiseIndex, code) {\n    env.promise_batch_action_deploy_contract(promiseIndex, code);\n}\nexport function promiseBatchActionFunctionCall(promiseIndex, methodName, args, amount, gas) {\n    env.promise_batch_action_function_call(promiseIndex, methodName, args, amount, gas);\n}\nexport function promiseBatchActionTransfer(promiseIndex, amount) {\n    env.promise_batch_action_transfer(promiseIndex, amount);\n}\nexport function promiseBatchActionStake(promiseIndex, amount, publicKey) {\n    env.promise_batch_action_stake(promiseIndex, amount, publicKey);\n}\nexport function promiseBatchActionAddKeyWithFullAccess(promiseIndex, publicKey, nonce) {\n    env.promise_batch_action_add_key_with_full_access(promiseIndex, publicKey, nonce);\n}\nexport function promiseBatchActionAddKeyWithFunctionCall(promiseIndex, publicKey, nonce, allowance, receiverId, methodNames) {\n    env.promise_batch_action_add_key_with_function_call(promiseIndex, publicKey, nonce, allowance, receiverId, methodNames);\n}\nexport function promiseBatchActionDeleteKey(promiseIndex, publicKey) {\n    env.promise_batch_action_delete_key(promiseIndex, publicKey);\n}\nexport function promiseBatchActionDeleteAccount(promiseIndex, beneficiaryId) {\n    env.promise_batch_action_delete_account(promiseIndex, beneficiaryId);\n}\nexport function promiseResultsCount() {\n    return env.promise_results_count();\n}\nexport var PromiseResult;\n(function (PromiseResult) {\n    PromiseResult[PromiseResult[\"NotReady\"] = 0] = \"NotReady\";\n    PromiseResult[PromiseResult[\"Successful\"] = 1] = \"Successful\";\n    PromiseResult[PromiseResult[\"Failed\"] = 2] = \"Failed\";\n})(PromiseResult || (PromiseResult = {}));\nexport function promiseResult(resultIdx) {\n    let status = env.promise_result(resultIdx, 0);\n    if (status == PromiseResult.Successful) {\n        return env.read_register(0);\n    }\n    else if (status == PromiseResult.Failed ||\n        status == PromiseResult.NotReady) {\n        return status;\n    }\n    else {\n        panic(`Unexpected return code: ${status}`);\n    }\n}\nexport function promiseReturn(promiseIdx) {\n    env.promise_return(promiseIdx);\n}\nexport function storageWrite(key, value) {\n    let exist = env.storage_write(key, value, EVICTED_REGISTER);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function storageRemove(key) {\n    let exist = env.storage_remove(key, EVICTED_REGISTER);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function storageByteCost() {\n    return 10000000000000000000n;\n}\n","import * as near from \"./api\";\nexport class NearContract {\n    deserialize() {\n        const rawState = near.storageRead(\"STATE\");\n        if (rawState) {\n            const state = JSON.parse(rawState);\n            // reconstruction of the contract class object from plain object\n            let c = this.default();\n            Object.assign(this, state);\n            for (const item in c) {\n                if (c[item].constructor?.deserialize !== undefined) {\n                    this[item] = c[item].constructor.deserialize(this[item]);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Contract state is empty\");\n        }\n    }\n    serialize() {\n        near.storageWrite(\"STATE\", JSON.stringify(this));\n    }\n    static deserializeArgs() {\n        let args = near.input();\n        return JSON.parse(args || \"{}\");\n    }\n    static serializeReturn(ret) {\n        return JSON.stringify(ret);\n    }\n    init() { }\n}\n","import * as near from '../api';\nexport class LookupMap {\n    constructor(keyPrefix) {\n        this.keyPrefix = keyPrefix;\n    }\n    containsKey(key) {\n        let storageKey = this.keyPrefix + JSON.stringify(key);\n        return near.storageHasKey(storageKey);\n    }\n    get(key) {\n        let storageKey = this.keyPrefix + JSON.stringify(key);\n        let raw = near.storageRead(storageKey);\n        if (raw !== null) {\n            return JSON.parse(raw);\n        }\n        return null;\n    }\n    remove(key) {\n        let storageKey = this.keyPrefix + JSON.stringify(key);\n        if (near.storageRemove(storageKey)) {\n            return JSON.parse(near.storageGetEvicted());\n        }\n        return null;\n    }\n    set(key, value) {\n        let storageKey = this.keyPrefix + JSON.stringify(key);\n        let storageValue = JSON.stringify(value);\n        if (near.storageWrite(storageKey, storageValue)) {\n            return JSON.parse(near.storageGetEvicted());\n        }\n        return null;\n    }\n    extend(objects) {\n        for (let kv of objects) {\n            this.set(kv[0], kv[1]);\n        }\n    }\n    serialize() {\n        return JSON.stringify(this);\n    }\n    // converting plain object to class object\n    static deserialize(data) {\n        return new LookupMap(data.keyPrefix);\n    }\n}\n","export function u8ArrayToBytes(array) {\n    let ret = \"\";\n    for (let e of array) {\n        ret += String.fromCharCode(e);\n    }\n    return ret;\n}\n// TODO this function is a bit broken and the type can't be string\n// TODO for more info: https://github.com/near/near-sdk-js/issues/78\nexport function bytesToU8Array(bytes) {\n    let ret = new Uint8Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        ret[i] = bytes.charCodeAt(i);\n    }\n    return ret;\n}\nexport function bytes(strOrU8Array) {\n    if (typeof strOrU8Array == \"string\") {\n        return checkStringIsBytes(strOrU8Array);\n    }\n    else if (strOrU8Array instanceof Uint8Array) {\n        return u8ArrayToBytes(strOrU8Array);\n    }\n    throw new Error(\"bytes: expected string or Uint8Array\");\n}\nfunction checkStringIsBytes(str) {\n    for (let i = 0; i < str.length; i++) {\n        if (str.charCodeAt(i) > 255) {\n            throw new Error(`string ${str} at index ${i}: ${str[i]} is not a valid byte`);\n        }\n    }\n    return str;\n}\nexport function assert(b, str) {\n    if (b) {\n        return;\n    }\n    else {\n        throw Error(\"assertion failed: \" + str);\n    }\n}\n","import * as near from \"../api\";\nimport { u8ArrayToBytes } from \"../utils\";\nconst ERR_INDEX_OUT_OF_BOUNDS = \"Index out of bounds\";\nconst ERR_INCONSISTENT_STATE = \"The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?\";\nfunction indexToKey(prefix, index) {\n    let data = new Uint32Array([index]);\n    let array = new Uint8Array(data.buffer);\n    let key = u8ArrayToBytes(array);\n    return prefix + key;\n}\n/// An iterable implementation of vector that stores its content on the trie.\n/// Uses the following map: index -> element\nexport class Vector {\n    constructor(prefix) {\n        this.length = 0;\n        this.prefix = prefix;\n    }\n    len() {\n        return this.length;\n    }\n    isEmpty() {\n        return this.length == 0;\n    }\n    get(index) {\n        if (index >= this.length) {\n            return null;\n        }\n        let storageKey = indexToKey(this.prefix, index);\n        return JSON.parse(near.storageRead(storageKey));\n    }\n    /// Removes an element from the vector and returns it in serialized form.\n    /// The removed element is replaced by the last element of the vector.\n    /// Does not preserve ordering, but is `O(1)`.\n    swapRemove(index) {\n        if (index >= this.length) {\n            throw new Error(ERR_INDEX_OUT_OF_BOUNDS);\n        }\n        else if (index + 1 == this.length) {\n            return this.pop();\n        }\n        else {\n            let key = indexToKey(this.prefix, index);\n            let last = this.pop();\n            if (near.storageWrite(key, JSON.stringify(last))) {\n                return JSON.parse(near.storageGetEvicted());\n            }\n            else {\n                throw new Error(ERR_INCONSISTENT_STATE);\n            }\n        }\n    }\n    push(element) {\n        let key = indexToKey(this.prefix, this.length);\n        this.length += 1;\n        near.storageWrite(key, JSON.stringify(element));\n    }\n    pop() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        else {\n            let lastIndex = this.length - 1;\n            let lastKey = indexToKey(this.prefix, lastIndex);\n            this.length -= 1;\n            if (near.storageRemove(lastKey)) {\n                return JSON.parse(near.storageGetEvicted());\n            }\n            else {\n                throw new Error(ERR_INCONSISTENT_STATE);\n            }\n        }\n    }\n    replace(index, element) {\n        if (index >= this.length) {\n            throw new Error(ERR_INDEX_OUT_OF_BOUNDS);\n        }\n        else {\n            let key = indexToKey(this.prefix, index);\n            if (near.storageWrite(key, JSON.stringify(element))) {\n                return JSON.parse(near.storageGetEvicted());\n            }\n            else {\n                throw new Error(ERR_INCONSISTENT_STATE);\n            }\n        }\n    }\n    extend(elements) {\n        for (let element of elements) {\n            this.push(element);\n        }\n    }\n    [Symbol.iterator]() {\n        return new VectorIterator(this);\n    }\n    clear() {\n        for (let i = 0; i < this.length; i++) {\n            let key = indexToKey(this.prefix, i);\n            near.storageRemove(key);\n        }\n        this.length = 0;\n    }\n    toArray() {\n        let ret = [];\n        for (let v of this) {\n            ret.push(v);\n        }\n        return ret;\n    }\n    serialize() {\n        return JSON.stringify(this);\n    }\n    // converting plain object to class object\n    static deserialize(data) {\n        let vector = new Vector(data.prefix);\n        vector.length = data.length;\n        return vector;\n    }\n}\nexport class VectorIterator {\n    constructor(vector) {\n        this.current = 0;\n        this.vector = vector;\n    }\n    next() {\n        if (this.current < this.vector.len()) {\n            let value = this.vector.get(this.current);\n            this.current += 1;\n            return { value, done: false };\n        }\n        return { value: null, done: true };\n    }\n}\n","import * as near from \"../api\";\nimport { u8ArrayToBytes, bytesToU8Array } from \"../utils\";\nimport { Vector, VectorIterator } from \"./vector\";\nconst ERR_INCONSISTENT_STATE = \"The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?\";\nexport class UnorderedMap {\n    constructor(prefix) {\n        this.length = 0;\n        this.prefix = prefix;\n        this.keyIndexPrefix = prefix + \"i\";\n        let indexKey = prefix + \"k\";\n        let indexValue = prefix + \"v\";\n        this.keys = new Vector(indexKey);\n        this.values = new Vector(indexValue);\n    }\n    len() {\n        let keysLen = this.keys.len();\n        let valuesLen = this.values.len();\n        if (keysLen != valuesLen) {\n            throw new Error(ERR_INCONSISTENT_STATE);\n        }\n        return keysLen;\n    }\n    isEmpty() {\n        let keysIsEmpty = this.keys.isEmpty();\n        let valuesIsEmpty = this.values.isEmpty();\n        if (keysIsEmpty != valuesIsEmpty) {\n            throw new Error(ERR_INCONSISTENT_STATE);\n        }\n        return keysIsEmpty;\n    }\n    serializeIndex(index) {\n        let data = new Uint32Array([index]);\n        let array = new Uint8Array(data.buffer);\n        return u8ArrayToBytes(array);\n    }\n    deserializeIndex(rawIndex) {\n        let array = bytesToU8Array(rawIndex);\n        let data = new Uint32Array(array.buffer);\n        return data[0];\n    }\n    getIndexRaw(key) {\n        let indexLookup = this.keyIndexPrefix + JSON.stringify(key);\n        let indexRaw = near.storageRead(indexLookup);\n        return indexRaw;\n    }\n    get(key) {\n        let indexRaw = this.getIndexRaw(key);\n        if (indexRaw) {\n            let index = this.deserializeIndex(indexRaw);\n            let value = this.values.get(index);\n            if (value) {\n                return value;\n            }\n            else {\n                throw new Error(ERR_INCONSISTENT_STATE);\n            }\n        }\n        return null;\n    }\n    set(key, value) {\n        let indexLookup = this.keyIndexPrefix + JSON.stringify(key);\n        let indexRaw = near.storageRead(indexLookup);\n        if (indexRaw) {\n            let index = this.deserializeIndex(indexRaw);\n            return this.values.replace(index, value);\n        }\n        else {\n            let nextIndex = this.len();\n            let nextIndexRaw = this.serializeIndex(nextIndex);\n            near.storageWrite(indexLookup, nextIndexRaw);\n            this.keys.push(key);\n            this.values.push(value);\n            return null;\n        }\n    }\n    remove(key) {\n        let indexLookup = this.keyIndexPrefix + JSON.stringify(key);\n        let indexRaw = near.storageRead(indexLookup);\n        if (indexRaw) {\n            if (this.len() == 1) {\n                // If there is only one element then swap remove simply removes it without\n                // swapping with the last element.\n                near.storageRemove(indexLookup);\n            }\n            else {\n                // If there is more than one element then swap remove swaps it with the last\n                // element.\n                let lastKey = this.keys.get(this.len() - 1);\n                if (!lastKey) {\n                    throw new Error(ERR_INCONSISTENT_STATE);\n                }\n                near.storageRemove(indexLookup);\n                // If the removed element was the last element from keys, then we don't need to\n                // reinsert the lookup back.\n                if (lastKey != key) {\n                    let lastLookupKey = this.keyIndexPrefix + JSON.stringify(lastKey);\n                    near.storageWrite(lastLookupKey, indexRaw);\n                }\n            }\n            let index = this.deserializeIndex(indexRaw);\n            this.keys.swapRemove(index);\n            return this.values.swapRemove(index);\n        }\n        return null;\n    }\n    clear() {\n        for (let key of this.keys) {\n            let indexLookup = this.keyIndexPrefix + JSON.stringify(key);\n            near.storageRemove(indexLookup);\n        }\n        this.keys.clear();\n        this.values.clear();\n    }\n    toArray() {\n        let ret = [];\n        for (let v of this) {\n            ret.push(v);\n        }\n        return ret;\n    }\n    [Symbol.iterator]() {\n        return new UnorderedMapIterator(this);\n    }\n    extend(kvs) {\n        for (let [k, v] of kvs) {\n            this.set(k, v);\n        }\n    }\n    serialize() {\n        return JSON.stringify(this);\n    }\n    // converting plain object to class object\n    static deserialize(data) {\n        let map = new UnorderedMap(data.prefix);\n        // reconstruct UnorderedMap\n        map.length = data.length;\n        // reconstruct keys Vector\n        map.keys = new Vector(data.prefix + \"k\");\n        map.keys.length = data.keys.length;\n        // reconstruct values Vector\n        map.values = new Vector(data.prefix + \"v\");\n        map.values.length = data.values.length;\n        return map;\n    }\n}\nclass UnorderedMapIterator {\n    constructor(unorderedMap) {\n        this.keys = new VectorIterator(unorderedMap.keys);\n        this.values = new VectorIterator(unorderedMap.values);\n    }\n    next() {\n        let key = this.keys.next();\n        let value = this.values.next();\n        if (key.done != value.done) {\n            throw new Error(ERR_INCONSISTENT_STATE);\n        }\n        return { value: [key.value, value.value], done: key.done };\n    }\n}\n","import * as near from \"../api\";\nimport { u8ArrayToBytes, bytesToU8Array } from \"../utils\";\nimport { Vector } from \"./vector\";\nconst ERR_INCONSISTENT_STATE = \"The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?\";\nexport class UnorderedSet {\n    constructor(prefix) {\n        this.length = 0;\n        this.prefix = prefix;\n        this.elementIndexPrefix = prefix + \"i\";\n        let elementsPrefix = prefix + \"e\";\n        this.elements = new Vector(elementsPrefix);\n    }\n    len() {\n        return this.elements.len();\n    }\n    isEmpty() {\n        return this.elements.isEmpty();\n    }\n    serializeIndex(index) {\n        let data = new Uint32Array([index]);\n        let array = new Uint8Array(data.buffer);\n        return u8ArrayToBytes(array);\n    }\n    deserializeIndex(rawIndex) {\n        let array = bytesToU8Array(rawIndex);\n        let data = new Uint32Array(array.buffer);\n        return data[0];\n    }\n    contains(element) {\n        let indexLookup = this.elementIndexPrefix + JSON.stringify(element);\n        return near.storageHasKey(indexLookup);\n    }\n    set(element) {\n        let indexLookup = this.elementIndexPrefix + JSON.stringify(element);\n        if (near.storageRead(indexLookup)) {\n            return false;\n        }\n        else {\n            let nextIndex = this.len();\n            let nextIndexRaw = this.serializeIndex(nextIndex);\n            near.storageWrite(indexLookup, nextIndexRaw);\n            this.elements.push(element);\n            return true;\n        }\n    }\n    remove(element) {\n        let indexLookup = this.elementIndexPrefix + JSON.stringify(element);\n        let indexRaw = near.storageRead(indexLookup);\n        if (indexRaw) {\n            if (this.len() == 1) {\n                // If there is only one element then swap remove simply removes it without\n                // swapping with the last element.\n                near.storageRemove(indexLookup);\n            }\n            else {\n                // If there is more than one element then swap remove swaps it with the last\n                // element.\n                let lastElement = this.elements.get(this.len() - 1);\n                if (!lastElement) {\n                    throw new Error(ERR_INCONSISTENT_STATE);\n                }\n                near.storageRemove(indexLookup);\n                // If the removed element was the last element from keys, then we don't need to\n                // reinsert the lookup back.\n                if (lastElement != element) {\n                    let lastLookupElement = this.elementIndexPrefix + JSON.stringify(lastElement);\n                    near.storageWrite(lastLookupElement, indexRaw);\n                }\n            }\n            let index = this.deserializeIndex(indexRaw);\n            this.elements.swapRemove(index);\n            return true;\n        }\n        return false;\n    }\n    clear() {\n        for (let element of this.elements) {\n            let indexLookup = this.elementIndexPrefix + JSON.stringify(element);\n            near.storageRemove(indexLookup);\n        }\n        this.elements.clear();\n    }\n    toArray() {\n        let ret = [];\n        for (let v of this) {\n            ret.push(v);\n        }\n        return ret;\n    }\n    [Symbol.iterator]() {\n        return this.elements[Symbol.iterator]();\n    }\n    extend(elements) {\n        for (let element of elements) {\n            this.set(element);\n        }\n    }\n    serialize() {\n        return JSON.stringify(this);\n    }\n    // converting plain object to class object\n    static deserialize(data) {\n        let set = new UnorderedSet(data.prefix);\n        // reconstruct UnorderedSet\n        set.length = data.length;\n        // reconstruct Vector\n        let elementsPrefix = data.prefix + \"e\";\n        set.elements = new Vector(elementsPrefix);\n        set.elements.length = data.elements.length;\n        return set;\n    }\n}\n","import { Contract } from \".\";\n\n//defines the payout type we'll be returning as a part of the royalty standards.\nexport class Payout {\n    payout: { [accountId: string]: bigint };\n    constructor({ payout }: { payout: { [accountId: string]: bigint } }) {\n        this.payout = payout;\n    }\n}\n\nexport class NFTContractMetadata {\n    spec: string;\n    name: string;\n    symbol: string;\n    icon?: string;\n    base_uri?: string;\n    reference?: string;\n    reference_hash?: string;\n    \n    constructor(\n        {\n            spec, \n            name, \n            symbol, \n            icon, \n            baseUri, \n            reference, \n            referenceHash\n        }:{ \n            spec: string, \n            name: string, \n            symbol: string, \n            icon?: string, \n            baseUri?: string, \n            reference?: string, \n            referenceHash?: string\n        }) {\n        this.spec = spec  // required, essentially a version like \"nft-1.0.0\"\n        this.name = name  // required, ex. \"Mosaics\"\n        this.symbol = symbol // required, ex. \"MOSAIC\"\n        this.icon = icon // Data URL\n        this.base_uri = baseUri // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs\n        this.reference = reference // URL to a JSON file with more info\n        this.reference_hash = referenceHash // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.\n    }\n}\n\nexport class TokenMetadata {\n    title?: string;\n    description?: string;\n    media?: string;\n    media_hash?: string;\n    copies?: number;\n    issued_at?: string;\n    expires_at?: string;\n    starts_at?: string;\n    updated_at?: string;\n    extra?: string;\n    reference?: string;\n    reference_hash?: string;\n\n    constructor(\n        {\n            title, \n            description, \n            media, \n            mediaHash, \n            copies, \n            issuedAt, \n            expiresAt, \n            startsAt, \n            updatedAt, \n            extra, \n            reference, \n            referenceHash\n        }:{\n            title?: string, \n            description?: string, \n            media?: string, \n            mediaHash?: string, \n            copies?: number, \n            issuedAt?: string, \n            expiresAt?: string, \n            startsAt?: string, \n            updatedAt?: string, \n            extra?: string, \n            reference?: string, \n            referenceHash?: string}\n        ) {\n        this.title = title // ex. \"Arch Nemesis: Mail Carrier\" or \"Parcel #5055\"\n        this.description = description // free-form description\n        this.media = media // URL to associated media, preferably to decentralized, content-addressed storage\n        this.media_hash = mediaHash // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.\n        this.copies = copies // number of copies of this set of metadata in existence when token was minted.\n        this.issued_at = issuedAt // ISO 8601 datetime when token was issued or minted\n        this.expires_at = expiresAt // ISO 8601 datetime when token expires\n        this.starts_at = startsAt // ISO 8601 datetime when token starts being valid\n        this.updated_at = updatedAt // ISO 8601 datetime when token was last updated\n        this.extra = extra // anything extra the NFT wants to store on-chain. Can be stringified JSON.\n        this.reference = reference // URL to an off-chain JSON file with more info.\n        this.reference_hash = referenceHash // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.\n    }\n}\n\nexport class Token {\n    owner_id: string;\n    approved_account_ids: { [accountId: string]: number };\n    next_approval_id: number;\n    royalty: { [accountId: string]: number };\n\n    constructor({ \n        ownerId, \n        approvedAccountIds, \n        nextApprovalId, \n        royalty \n    }:{ \n        ownerId: string, \n        approvedAccountIds: { [accountId: string]: number }, \n        nextApprovalId: number, \n        royalty: { [accountId: string]: number } \n    }) {\n        //owner of the token\n        this.owner_id = ownerId,\n        //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID\n        this.approved_account_ids = approvedAccountIds,\n        //the next approval ID to give out. \n        this.next_approval_id = nextApprovalId,\n        //keep track of the royalty percentages for the token in a hash map\n        this.royalty = royalty\n    }\n}\n\n//The Json token is what will be returned from view calls. \nexport class JsonToken {\n    token_id: string;\n    owner_id: string;\n    metadata: TokenMetadata;\n    approved_account_ids: { [accountId: string]: number };\n    royalty: { [accountId: string]: number };\n\n    constructor({ \n        tokenId, \n        ownerId, \n        metadata, \n        approvedAccountIds, \n        royalty \n    }:{\n        tokenId: string,\n        ownerId: string,\n        metadata: TokenMetadata,\n        approvedAccountIds: { [accountId: string]: number },\n        royalty: { [accountId: string]: number }\n    }) {\n        //token ID\n        this.token_id = tokenId,\n        //owner of the token\n        this.owner_id = ownerId,\n        //token metadata\n        this.metadata = metadata,\n        //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID\n        this.approved_account_ids = approvedAccountIds,\n        //keep track of the royalty percentages for the token in a hash map\n        this.royalty = royalty\n    }\n}\n\n//get the information for a specific token ID\nexport function internalNftMetadata({\n    contract\n}:{\n    contract: Contract\n}): NFTContractMetadata {\n    return contract.metadata;\n}","\nimport { assert,NearContract, NearBindgen, near, call, view, LookupMap, UnorderedMap, Vector, UnorderedSet } from 'near-sdk-js'\nimport { NFTContractMetadata, Token, TokenMetadata, internalNftMetadata, JsonToken } from './metadata';\n// import { internalMint } from './mint';\n// import { internalNftToken, internalNftTransfer, internalNftTransferCall, internalResolveTransfer } from './nft_core';\nexport declare type Bytes = string;\nexport declare function u8ArrayToBytes(array: Uint8Array): string;\nexport declare function bytesToU8Array(bytes: Bytes): Uint8Array;\nexport declare function bytes(strOrU8Array: string | Uint8Array): Bytes;\nconst GAS_FOR_RESOLVE_TRANSFER = 40_000_000_000_000;\nconst GAS_FOR_NFT_ON_TRANSFER = 35_000_000_000_000;\nexport declare type Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n/// This spec can be treated like a version of the standard.\nexport const NFT_METADATA_SPEC = \"nft-1.0.0\";\n\n/// This is the name of the NFT standard we're using\nexport const NFT_STANDARD_NAME = \"nep171\";\n\n@NearBindgen\nexport class Contract extends NearContract {\n    owner_id: string;\n    tokensPerOwner: LookupMap;\n    tokensById: LookupMap;\n    tokenMetadataById: UnorderedMap;\n    metadata: NFTContractMetadata;\n\n    /*\n        initialization function (can only be called once).\n        this initializes the contract with metadata that was passed in and\n        the owner_id. \n    */\n    constructor({\n        owner_id, \n        metadata = {\n            spec: \"nft-1.0.0\",\n            name: \"NFTDawnContract\",\n            symbol: \"NFT\"\n        } \n    }) {\n        super()\n        this.owner_id = owner_id;\n        this.tokensPerOwner = new LookupMap(\"tokensPerOwner\");\n        this.tokensById = new LookupMap(\"tokensById\");\n        this.tokenMetadataById = new UnorderedMap(\"tokenMetadataById\");\n        this.metadata = metadata;\n    }\n\n    default() {\n        return new Contract({owner_id: ''})\n    }\n\n    /*\n        MINT\n    */\n    @call\n    nft_mint({ token_id, metadata, receiver_id, perpetual_royalties }) {\n        return this.internalMint({ contract: this, tokenId: token_id, metadata: metadata, receiverId: receiver_id, perpetualRoyalties: perpetual_royalties });\n    }\n\n    /*\n        CORE\n    */\n    @view\n    //get the information for a specific token ID\n    nft_token({ token_id }) {\n        return this.internalNftToken({ contract: this, tokenId: token_id });\n    }\n\n    @call\n    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver. \n    nft_transfer({ receiver_id, token_id, approval_id, memo }) {\n        return this.internalNftTransfer({ contract: this, receiverId: receiver_id, tokenId: token_id, approvalId: approval_id, memo: memo });\n    }\n\n    @call\n    //implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract\n    nft_transfer_call({ receiver_id, token_id, approval_id, memo, msg }) {\n        return this.internalNftTransferCall({ contract: this, receiverId: receiver_id, tokenId: token_id, approvalId: approval_id, memo: memo, msg: msg });\n    }\n\n    @call\n    //resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method\n    //returns true if the token was successfully transferred to the receiver_id\n    nft_resolve_transfer({ authorized_id, owner_id, receiver_id, token_id, approved_account_ids, memo }) {\n        return this.internalResolveTransfer({ contract: this, authorizedId: authorized_id, ownerId: owner_id, receiverId: receiver_id, tokenId: token_id, approvedAccountIds: approved_account_ids, memo: memo });\n    }\n\n\n    // ***** Helper functions *****//\n    internalMint({\n        contract,\n        tokenId,\n        metadata,\n        receiverId,\n        perpetualRoyalties\n    }:{ \n        contract: Contract, \n        tokenId: string, \n        metadata: TokenMetadata, \n        receiverId: string \n        perpetualRoyalties: {[key: string]: number}\n    }): void {\n        //measure the initial storage being used on the contract TODO\n        let initialStorageUsage = near.storageUsage();\n    \n        // create a royalty map to store in the token\n        let royalty: { [accountId: string]: number } = {}\n    \n        // if perpetual royalties were passed into the function: TODO: add isUndefined fn\n        if (perpetualRoyalties != null) {\n            //make sure that the length of the perpetual royalties is below 7 since we won't have enough GAS to pay out that many people\n            assert(Object.keys(perpetualRoyalties).length < 7, \"Cannot add more than 6 perpetual royalty amounts\");\n            \n            //iterate through the perpetual royalties and insert the account and amount in the royalty map\n            Object.entries(perpetualRoyalties).forEach(([account, amount], index) => {\n                royalty[account] = amount;\n            });\n        }\n    \n        //specify the token struct that contains the owner ID \n        let token = new Token ({\n            //set the owner ID equal to the receiver ID passed into the function\n            ownerId: receiverId,\n            //we set the approved account IDs to the default value (an empty map)\n            approvedAccountIds: {},\n            //the next approval ID is set to 0\n            nextApprovalId: 0,\n            //the map of perpetual royalties for the token (The owner will get 100% - total perpetual royalties)\n            royalty,\n        });\n    \n        //insert the token ID and token struct and make sure that the token doesn't exist\n        assert(!contract.tokensById.containsKey(tokenId), \"Token already exists\");\n        contract.tokensById.set(tokenId, token)\n    \n        //insert the token ID and metadata\n        contract.tokenMetadataById.set(tokenId, metadata);\n    \n        //call the internal method for adding the token to the owner\n        this.internalAddTokenToOwner(contract, token.owner_id, tokenId)\n    \n        // Construct the mint log as per the events standard.\n        let nftMintLog = {\n            // Standard name (\"nep171\").\n            standard: NFT_STANDARD_NAME,\n            // Version of the standard (\"nft-1.0.0\").\n            version: NFT_METADATA_SPEC,\n            // The data related with the event stored in a vector.\n            event: \"nft_mint\",\n            data: [\n                {\n                    // Owner of the token.\n                    owner_id: token.owner_id,\n                    // Vector of token IDs that were minted.\n                    token_ids: [tokenId],\n                }\n            ]\n        }\n        \n        // Log the json.\n        near.log(`EVENT_JSON:${JSON.stringify(nftMintLog)}`);\n    }\n\n    \n\n    internalNftToken({\n        contract,\n        tokenId\n    }:{ \n        contract: Contract, \n        tokenId: string \n    }) {\n        let token = contract.tokensById.get(tokenId) as Token;\n        //if there wasn't a token ID in the tokens_by_id collection, we return None\n        if (token == null) {\n            return null;\n        }\n    \n        //if there is some token ID in the tokens_by_id collection\n        //we'll get the metadata for that token\n        let metadata = contract.tokenMetadataById.get(tokenId) as TokenMetadata;\n        \n        //we return the JsonToken\n        let jsonToken = new JsonToken({\n            tokenId: tokenId,\n            ownerId: token.owner_id,\n            metadata,\n            approvedAccountIds: token.approved_account_ids,\n            royalty: token.royalty\n        });\n        return jsonToken;\n    }\n\n    internalNftTransfer({\n        contract,\n        receiverId,\n        tokenId,\n        approvalId,\n        memo,\n    }:{\n        contract: Contract, \n        receiverId: string, \n        tokenId: string, \n        approvalId: number\n        memo: string\n    }) {\n    }\n\n    internalNftTransferCall({\n        contract,\n        receiverId,\n        tokenId,\n        approvalId,\n        memo,\n        msg\n    }:{\n        contract: Contract,\n        receiverId: string, \n        tokenId: string, \n        approvalId: number,\n        memo: string,\n        msg: string  \n    }) {\n\n        //get the sender to transfer the token from the sender to the receiver\n        let senderId = near.predecessorAccountId();\n    \n        //call the internal transfer method and get back the previous token so we can refund the approved account IDs\n        let previousToken = this.internalTransfer(\n            contract,\n            senderId,\n            receiverId,\n            tokenId,\n            approvalId,\n            memo,\n        );\n    \n        // Initiating receiver's call and the callback\n        const promise = near.promiseBatchCreate(receiverId);\n        near.promiseBatchActionFunctionCall(\n            promise, \n            \"nft_on_transfer\", \n            bytes(JSON.stringify({ \n                sender_id: senderId,\n                previous_owner_id: previousToken.owner_id,\n                token_id: tokenId,\n                msg\n            })), \n            0, // no deposit \n            GAS_FOR_NFT_ON_TRANSFER\n        );\n    \n        // We then resolve the promise and call nft_resolve_transfer on our own contract\n        near.promiseThen(\n            promise, \n            near.currentAccountId(), \n            \"nft_resolve_transfer\", \n            bytes(JSON.stringify({\n                owner_id: previousToken.owner_id,\n                receiver_id: receiverId,\n                token_id: tokenId,\n                approved_account_ids: previousToken.approved_account_ids\n            })), \n            0, // no deposit \n            GAS_FOR_RESOLVE_TRANSFER\n        );\n        return near.promiseReturn(promise);\n    }\n\n\n    internalTransfer(contract: Contract, senderId: string, receiverId: string, tokenId: string, approvalId: number, memo: string): Token {\n        //get the token object by passing in the token_id\n        let token = contract.tokensById.get(tokenId) as Token;\n        if (token == null) {\n            near.panic(\"no token found\");\n        }\n    \n        //if the sender doesn't equal the owner, we check if the sender is in the approval list\n        if (senderId != token.owner_id) {\n            //if the token's approved account IDs doesn't contain the sender, we panic\n            if (!token.approved_account_ids.hasOwnProperty(senderId)) {\n                near.panic(\"Unauthorized\");\n            }\n    \n            // If they included an approval_id, check if the sender's actual approval_id is the same as the one included\n            if (approvalId != null) {\n                //get the actual approval ID\n                let actualApprovalId = token.approved_account_ids[senderId];\n                //if the sender isn't in the map, we panic\n                if (actualApprovalId == null) {\n                    near.panic(\"Sender is not approved account\");\n                }\n    \n                //make sure that the actual approval ID is the same as the one provided\n                assert(actualApprovalId == approvalId, `The actual approval_id ${actualApprovalId} is different from the given approval_id ${approvalId}`);\n            }\n        }\n    \n        //we make sure that the sender isn't sending the token to themselves\n        assert(token.owner_id != receiverId, \"The token owner and the receiver should be different\")\n    \n        //we remove the token from it's current owner's set\n        this.internalRemoveTokenFromOwner(contract, token.owner_id, tokenId);\n        //we then add the token to the receiver_id's set\n        this.internalAddTokenToOwner(contract, receiverId, tokenId);\n    \n        //we create a new token struct \n        let newToken = new Token ({\n            ownerId: receiverId,\n            //reset the approval account IDs\n            approvedAccountIds: {},\n            nextApprovalId: token.next_approval_id,\n            //we copy over the royalties from the previous token\n            royalty: token.royalty,\n        });\n    \n        //insert that new token into the tokens_by_id, replacing the old entry \n        contract.tokensById.set(tokenId, newToken);\n    \n        //if there was some memo attached, we log it. \n        if (memo != null) {\n            near.log(`Memo: ${memo}`);\n        }\n    \n        // Default the authorized ID to be None for the logs.\n        let authorizedId;\n    \n        //if the approval ID was provided, set the authorized ID equal to the sender\n        if (approvalId != null) {\n            authorizedId = senderId\n        }\n    \n        // Construct the transfer log as per the events standard.\n        let nftTransferLog = {\n            // Standard name (\"nep171\").\n            standard: NFT_STANDARD_NAME,\n            // Version of the standard (\"nft-1.0.0\").\n            version: NFT_METADATA_SPEC,\n            // The data related with the event stored in a vector.\n            event: \"nft_transfer\",\n            data: [\n                {\n                    // The optional authorized account ID to transfer the token on behalf of the old owner.\n                    authorized_id: authorizedId,\n                    // The old owner's account ID.\n                    old_owner_id: token.owner_id,\n                    // The account ID of the new owner of the token.\n                    new_owner_id: receiverId,\n                    // A vector containing the token IDs as strings.\n                    token_ids: [tokenId],\n                    // An optional memo to include.\n                    memo,\n                }\n            ]\n        }\n    \n        // Log the serialized json.\n        near.log(JSON.stringify(nftTransferLog));\n    \n        //return the previous token object that was transferred.\n        return token\n    }\n    internalRemoveTokenFromOwner(contract: Contract, accountId: string, tokenId: string) {\n        //we get the set of tokens that the owner has\n        let tokenSet = UnorderedSet.deserialize(contract.tokensPerOwner.get(accountId) as UnorderedSet)\n        //if there is no set of tokens for the owner, we panic with the following message:\n        if (tokenSet == null) {\n            near.panic(\"Token should be owned by the sender\");\n        }\n    \n        //we remove the the token_id from the set of tokens\n        tokenSet.remove(tokenId)\n    \n        //if the token set is now empty, we remove the owner from the tokens_per_owner collection\n        if (tokenSet.isEmpty()) {\n            contract.tokensPerOwner.remove(accountId);\n        } else { //if the token set is not empty, we simply insert it back for the account ID. \n            contract.tokensPerOwner.set(accountId, tokenSet);\n        }\n    }\n\n    internalAddTokenToOwner(contract: Contract, accountId: string, tokenId: string) {\n        //get the set of tokens for the given account\n        let tokenSet = UnorderedSet.deserialize(contract.tokensPerOwner.get(accountId) as UnorderedSet)\n    \n        if(tokenSet == null) {\n            //if the account doesn't have any tokens, we create a new unordered set\n            tokenSet = new UnorderedSet(\"tokensPerOwner\" + accountId.toString());\n        }\n    \n        //we insert the token ID into the set\n        tokenSet.set(tokenId);\n    \n        //we insert that set for the given account ID. \n        contract.tokensPerOwner.set(accountId, tokenSet);\n    }\n\n    internalResolveTransfer({\n        contract,\n        authorizedId,\n        ownerId,\n        receiverId,\n        tokenId,\n        approvedAccountIds,\n        memo\n    }:{\n        contract: Contract,\n        authorizedId: string,\n        ownerId: string,\n        receiverId: string,\n        tokenId: string,\n        approvedAccountIds: { [key: string]: number },\n        memo: string    \n    }) {\n        assert(near.currentAccountId() === near.predecessorAccountId(), \"Only the contract itself can call this method\");\n        // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`\n        // call result.\n        let result = near.promiseResult(0);\n        if (typeof result === 'string') {\n            //As per the standard, the nft_on_transfer should return whether we should return the token to it's owner or not\n            //if we need don't need to return the token, we simply return true meaning everything went fine\n            if (result === 'false') {\n                /* \n                    since we've already transferred the token and nft_on_transfer returned false, we don't have to \n                    revert the original transfer and thus we can just return true since nothing went wrong.\n                */\n                //we refund the owner for releasing the storage used up by the approved account IDs\n                return true;\n            }\n        }\n    \n\n    \n        //we remove the token from the receiver\n        this.internalRemoveTokenFromOwner(contract, receiverId, tokenId);\n        //we add the token to the original owner\n        this.internalAddTokenToOwner(contract, ownerId, tokenId);\n    \n    \n    \n        /*\n            We need to log that the NFT was reverted back to the original owner.\n            The old_owner_id will be the receiver and the new_owner_id will be the\n            original owner of the token since we're reverting the transfer.\n        */\n    \n        // Construct the transfer log as per the events standard.\n        let nftTransferLog = {\n            // Standard name (\"nep171\").\n            standard: NFT_STANDARD_NAME,\n            // Version of the standard (\"nft-1.0.0\").\n            version: NFT_METADATA_SPEC,\n            // The data related with the event stored in a vector.\n            event: \"nft_transfer\",\n            data: [\n                {\n                    // The optional authorized account ID to transfer the token on behalf of the old owner.\n                    authorized_id: authorizedId,\n                    // The old owner's account ID.\n                    old_owner_id: receiverId,\n                    // The account ID of the new owner of the token.\n                    new_owner_id: ownerId,\n                    // A vector containing the token IDs as strings.\n                    token_ids: [tokenId],\n                    // An optional memo to include.\n                    memo,\n                }\n            ]\n        }\n    \n        // Log the serialized json.\n        near.log(JSON.stringify(nftTransferLog));\n    \n        //return false\n        return false\n    }\n}"],"names":["call","target","key","descriptor","view","NearBindgen","_init","args","deserializeArgs","ret","init","serialize","_get","Object","create","prototype","U64_MAX","EVICTED_REGISTER","log","params","env","map","x","undefined","JSON","stringify","join","predecessorAccountId","predecessor_account_id","read_register","panic","msg","storageRead","storage_read","storageHasKey","storage_has_key","storageGetEvicted","currentAccountId","current_account_id","input","storageUsage","storage_usage","promiseThen","promiseIndex","accountId","methodName","amount","gas","promise_then","promiseBatchCreate","promise_batch_create","promiseBatchActionFunctionCall","promise_batch_action_function_call","PromiseResult","promiseResult","resultIdx","status","promise_result","Successful","Failed","NotReady","promiseReturn","promiseIdx","promise_return","storageWrite","value","exist","storage_write","storageRemove","storage_remove","NearContract","deserialize","rawState","near","state","parse","c","default","assign","item","constructor","Error","serializeReturn","LookupMap","keyPrefix","containsKey","storageKey","get","raw","remove","set","storageValue","extend","objects","kv","data","u8ArrayToBytes","array","e","String","fromCharCode","bytesToU8Array","bytes","Uint8Array","length","i","charCodeAt","assert","b","str","ERR_INDEX_OUT_OF_BOUNDS","ERR_INCONSISTENT_STATE","indexToKey","prefix","index","Uint32Array","buffer","Vector","len","isEmpty","swapRemove","pop","last","push","element","lastIndex","lastKey","replace","elements","Symbol","iterator","VectorIterator","clear","toArray","v","vector","current","next","done","UnorderedMap","keyIndexPrefix","indexKey","indexValue","keys","values","keysLen","valuesLen","keysIsEmpty","valuesIsEmpty","serializeIndex","deserializeIndex","rawIndex","getIndexRaw","indexLookup","indexRaw","nextIndex","nextIndexRaw","lastLookupKey","UnorderedMapIterator","kvs","k","unorderedMap","UnorderedSet","elementIndexPrefix","elementsPrefix","contains","lastElement","lastLookupElement","Token","ownerId","approvedAccountIds","nextApprovalId","royalty","owner_id","approved_account_ids","next_approval_id","JsonToken","tokenId","metadata","token_id","GAS_FOR_RESOLVE_TRANSFER","GAS_FOR_NFT_ON_TRANSFER","NFT_METADATA_SPEC","NFT_STANDARD_NAME","Contract","spec","name","symbol","tokensPerOwner","tokensById","tokenMetadataById","nft_mint","receiver_id","perpetual_royalties","internalMint","contract","receiverId","perpetualRoyalties","nft_token","internalNftToken","nft_transfer","approval_id","memo","internalNftTransfer","approvalId","nft_transfer_call","internalNftTransferCall","nft_resolve_transfer","authorized_id","internalResolveTransfer","authorizedId","entries","forEach","account","token","internalAddTokenToOwner","nftMintLog","standard","version","event","token_ids","jsonToken","senderId","previousToken","internalTransfer","promise","sender_id","previous_owner_id","hasOwnProperty","actualApprovalId","internalRemoveTokenFromOwner","newToken","nftTransferLog","old_owner_id","new_owner_id","tokenSet","toString","result"],"mappings":"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"}